@allure.id('2501446')
@pytest.mark.integration
@allure.feature('Tables')
@allure.story('Обсолет')
@allure.label('layer', 'system')
@allure.tag('Dynamic')
@allure.label('title', 'Корректность перевода таблицы в обсолет')
@allure.description('Проверяем что не осталось дагов, зависящих от переводимой в обсолет таблицы')
def test_obsol_dag_tables(package_dag_by_repo, package, vial_prefix, mg_replica_helper, sas_script_parser) -> None:
    with allure.step('Получаем список дагов(s) из конфига'):
        current_dags = {dag.Name for dag in package.getMetaObjects('Dag{}')}
        renamed_objects = {package._get_obj_name_before_renaming(dag, 'Dag') for dag in current_dags}
        config_dags = current_dags | renamed_objects

        dags_to_print = '\n'.join(config_dags)
        with allure.step(dags_to_print):
            pass
    with allure.step('Определяем obsolete_tables из мета-объектов пакета (все Obsolete + переименованные)'):
        # Инициализация множества кандидатов (берём все, не только первый)
        candidate_tables = set()

        # 1) Все явные Obsolete в пакете (включаем все)
        obsolete_meta = {table.Name.replace('<>_', 'prod_').lower() for table in package.getMetaObjects('GpTable{o}')}
        if obsolete_meta:
            candidate_tables.update(obsolete_meta)

        # 2) Дополняем таблицами, у которых есть имя до переименования (добавляем и текущее, и предыдущее)
        renamed_meta = set()
        for table in package.getMetaObjects('GpTable{}'):
            try:
                prev_name = package._get_obj_name_before_renaming(table.Name, 'GpTable')
            except Exception:
                prev_name = None
            if prev_name and prev_name != table.Name:
                renamed_meta.add(table.Name.replace('<>_', 'prod_').lower())
                renamed_meta.add(prev_name.replace('<>_', 'prod_').lower())

        if renamed_meta:
            candidate_tables.update(renamed_meta)

        # 3) Fallback через таргет дага — закомментирован по просьбе (минимальное изменение)
        # if not candidate_tables:
        #     target_tables = package_dag_by_repo.get_target_tables()
        #     if not target_tables:
        #         for transform in package_dag_by_repo.transforms:
        #             if transform.get('type') == TediGpTransforms.gp_view.value:
        #                 target_tables.extend(list(transform.get('params', {}).get('entity_target', {}).values()))
        #     if target_tables:
        #         candidate_tables.add(target_tables[0].replace('test_', 'prod_').replace('<>_', 'prod_').lower())

    with allure.step('Получаем urn таблицы в DataDetective'):
        result = mg_replica_helper.get_urn_of_object(obsolete_table)
        assert result, 'Таблица не найдена в DataDetective. Необходимо проверить зависимости вручную.'

        urn, phys_table = result[0]
        url = f'https://dd.tcsbank.ru/{urn}'
        allure.dynamic.link(url, name=f'Link to DataDetective: {phys_table}')

        with allure.step(urn):
            pass

    with allure.step('Ищем в DataDetective зависимые от таблицы даги'):
        dep_dags = {obj[0] for obj in mg_replica_helper.get_depend_etl_objects_by_urn(urn) if obj[1] == 'DAG'}

        dags_to_print = '\n'.join(sorted(dep_dags))
        with allure.step(dags_to_print):
            pass

    if dep_dags:
        with allure.step('Проверяем, что зависимые даги есть в конфиге'):
            depend_not_in_config = dep_dags - config_dags

            assert not depend_not_in_config, f'От таблицы {obsolete_table} зависят объекты, ' \
                                             f'которых нет в конфиге: {depend_not_in_config}. ' \
                                             f'Необходимо проверить, что все зависимости учтены.'

    with allure.step('Проверяем, что таблица переводится в обсолет'):
        obsolete_tables_from_package = {table.Name.replace('<>_', 'prod_') for table
                                        in package.getMetaObjects('GpTable{o}')}
        assert obsolete_table in obsolete_tables_from_package, f'В пакете не найдена таблица {obsolete_table} ' \
                                                               f'с флагом Obsolete. ' \
                                                               f'Проверьте перевод таблицы в обсолет вручную.'
