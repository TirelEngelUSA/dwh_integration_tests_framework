Собеседование стажеров

Что ожидаем
Понимание базовых технологий

Описание
Имеет представление про базовые технологии.
В идеале чтобы кандидат не только слышал что что-то существует, но и потратил немного времени. на потрогать, и примерно понимал для чего оно нужно

Что хорошо
Кандидат знает и трогал docker и взаимодействовал с контейнерами
Кандидат в курсе про существование брокеров сообщений
Кандидат в курсе что существует CI/CD и примерно понимает что это такое и зачем
Есть базовые знания по БД
Список интересного:
docker
брокеры сообщений (kafka/rabbitMQ)
redis (NoSQL любые тоже будет ок, если знает разницу между SQL и NoSQL, вообще отлично)
БД (PG, MySQL etc...)

Как проверить
Спросить напрямую про то, с какими инструментами/технологиями работал
Задать вопросы по конкретным технологиям (с допом в виде уточнений)



Что ожидаем
Базовое понимание ООП

Описание
Знания принципов ООП и для чего оно нужно должно быть. 

Что хорошо
Кандидат должен назвать принципы ООП.
Если сможет раскрыть их - будет отлично

Как проверить
вопросы про ООП



Что ожидаем
Хотя бы понимание что такое паттерны и для чего они нужны

Описание
Знание того, что это, для чего нужно и хотя бы самые базовые из них (singleton, decorator, fabric) 

Что хорошо
Кандидат должен знать что они существуют и для чего они нужны.
Сможет рассказать про базовые паттерны

Как проверить
Вопрос про знание паттернов.
Практическая задача на рефакторинг/и или написание (может пересекаться со знанием Py)




Что ожидаем
Знание backend технологий

Описание
В идеале кандидат должен не только уметь решать задачки с leetcode, но и понимать технологии которые используются в backend разработке

Что хорошо
Понимание что такое HTTP и как работает. Чем HTTP отличается от HTTPS.
Знает что такое API и может назвать несколько (rest, soap, graphql, socket)
Знает про существование ORM, 
В идеале, знает про юнит-тесты 
В идеале в курсе про архитектуру (как минимум слышал про клиент-сервер/сервис/микро-сервис)
Общий список:
HTTP/HTTPS
API 
тесты
фремворки для backend (flask/django/fastapi/starlette etc...)

Как проверить
Вопросы про HTTP
Вопросы про API
Спросить про ORM
Спросить про тесты
Спросить работал ли с чем то в плане написания backend



Что ожидаем
Python

Описание
Знание базовых конструкций языка, понимать что и для чего может использоваться.
Знание концепций python, его работы и особенностей (GIL, как работает наследование etc...)

Что хорошо
База:
Знает что такое GIL и как оно работает
Знает про базовые конструкции языка (циклы, ветвления, функции, классы, если знает про switch case/моржа - отдельный +)
Знает про magic методы и может назвать что то помимо init, 
Знает типы данных и их особенности
Знает про исключения, как вызвывать, как обрабатывать
Знает про пакетные менеджеры (если знает что то кроме pip - прекрасно)
Знает про comprehansions
Знает что такое генераторы
Слышал про декораторы (в идеале сможет решить задачу)
Знает о существовании threading/multiprocessing/asyncio
Дополнительные плюсики:
Понимает как работает наследование в python и возможно слышал про MRO (если знает про миксины и множественное наследование - прекрасно)
Знает про существование Enum, dataclass и подобного (если назовет pydantic - прекрасно)
Возможно слышал про анотации типов, для чего они нужны и как могут быть полезны
трогал collections
трогал functools

Как проверить
теоретические вопросы
практика




Практика
Есть массив со случайным количеством элементов случайных типов. Отфильтровать массив таким образом, чтобы в результате остались только элементы с необходимым типом

m = [1,100, 15, 'len', 1.1, 'h', 'aac', (1,2,3), 'p', 1.11, 3.14, {5,4,3}, {'a': 1, 'b': 2}]
 
 
def filter1(collection, filter_type):
    return list(filter(lambda x: type(x) == filter_type, collection))
 
 
def filter2(collection, filter_type):
    return [x for x in collection if type(x) == filter_type]
 
 
def filter3(collection, filter_type):
    res = []
    for item in collection:
        if type(item) is filter_type:
            res.append(item)
    return res
 Калькулятор

class Calc:
 
    @staticmethod
    def check_type(a, b):
        # или аналогичное по контексту
        res = all([True if isinstance(item, (int, float)) else False for item in (a, b)])
        assert res, "тип не соответствует"
         
    @staticmethod
    def add(a, b):
        Calc.check_type(a, b)
        return a+b
 
    @staticmethod
    def minus(a, b):
        Calc.check_type(a, b)
        return a - b
 
    @staticmethod
    def mult(a, b):
        Calc.check_type(a, b)
        return a * b
 
    @staticmethod
    def division(a, b):
        Calc.check_type(a, b)
        assert b != 0, "Нельзя делить на 0"
        return round(a / b, 2)
 
 
def func_calc(num_1, num_2, operator):
    if operator not in ["+", "-", "*", "/"]:
        raise ValueError(f"Недопустимый оператор {operator}")
 
    for i in [num_1, num_2]:
        if not isinstance(i, (int, float)):
            raise TypeError(f"Недопустимый тип данных: {type(i)}")
 
    match operator:
        case "+":
            return round(num_1 + num_2, 2) 
        case "-":
            return round(num_1 - num_2, 2)
        case "*":
            return round(num_1 * num_2, 2)
        case "/":
            if num_2 != 0:  # noqa
                return round(num_1 / num_2, 2)
            else:
                raise ZeroDivisionError("Нельзя делить на ноль")
Есть функция exception_riser в процессе работы которой срабатывают исключения исключения. Написать код который будет эти исключения отлавливать и печатать ошибку(при этом, не должно быть завершения по exception) *

# def exception_riser():
#    exc = choice([ValueError, AttributeError, Exception, ZeroDivisionError, NameError, TypeError])
#    raise exc(f"Это {exc.__name__}")
 
 
from functools import wraps
 
 
def deco(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            func()
        except Exception as e:
            print(f"Exception: {e}")
    return wrapper
 
 
@deco
def exception_riser():
   exc = choice([ValueError, AttributeError, Exception, ZeroDivisionError, NameError, TypeError])
   raise exc(f"Это {exc.__name__}")
 
exception_riser()
 
 
# в данном случае есть и другой вариант - а именно через глобальное значение sys.excepthook, которое обрабатывает вообще все исключения
